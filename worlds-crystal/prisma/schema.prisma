generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Champion {
  id             Int                 @id @default(autoincrement())
  key            String              @unique
  riotId         Int?
  name           String
  GameChampStats GameChampStats[]
  pickSelections UserPickSelection[] @relation("UserPickSelectionChampion")
}

model Player {
  id             Int                 @id @default(autoincrement())
  handle         String              @unique
  team           String?
  GameChampStats GameChampStats[]
  pickSelections UserPickSelection[] @relation("UserPickSelectionPlayer")
}

model Game {
  id         BigInt   @id @default(autoincrement())
  tournament String
  stage      String
  dateUtc    DateTime
  patch      String?
  blueTeam   String
  redTeam    String
  winnerTeam String

  // add this:
  oracleGameId String? @unique

  GameChampStats GameChampStats[]
}

model GameChampStats {
  id         BigInt  @id @default(autoincrement())
  gameId     BigInt
  side       Side
  playerId   Int?
  championId Int
  kills      Int     @default(0)
  deaths     Int     @default(0)
  assists    Int     @default(0)
  win        Boolean

  game     Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  player   Player?  @relation(fields: [playerId], references: [id])
  champion Champion @relation(fields: [championId], references: [id])

  @@unique([gameId, playerId], name: "game_player_unique")
}

enum Side {
  BLUE
  RED
}

model ExternalMetric {
  id        Int      @id @default(autoincrement())
  metricId  String   @unique
  data      Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Statistic {
  key         String              @id
  category    String
  question    String
  entityType  StatisticEntityType
  metricId    String
  points      Int
  constraints Json?

  picks UserPickSelection[]
}

enum StatisticEntityType {
  champion
  player
  team
  event_total
  boolean
}

model UserPickSelection {
  id           BigInt   @id @default(autoincrement())
  userPickId   BigInt
  statisticKey String
  championId   Int?
  playerId     Int?
  teamName     String?
  valueNumber  Float?
  valueBoolean Boolean?
  valueText    String?

  userPick  UserPick  @relation(fields: [userPickId], references: [id], onDelete: Cascade)
  statistic Statistic @relation(fields: [statisticKey], references: [key])
  champion  Champion? @relation("UserPickSelectionChampion", fields: [championId], references: [id])
  player    Player?   @relation("UserPickSelectionPlayer", fields: [playerId], references: [id])

  @@unique([userPickId, statisticKey], name: "user_pick_statistic_unique")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  // ðŸ‘‡ back-relation for picks
  picks UserPick[]
}

model UserPick {
  id     BigInt @id @default(autoincrement())
  userId String
  season Int

  selections UserPickSelection[]

  // ðŸ‘‡ rename to `user` and link to User.id
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, season])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
